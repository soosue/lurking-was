FileInputStream에서 read()는 int로 읽는다. 다른 read메소드를 보면 byte로 읽어들인다.
여기서 알아두어야 하는 점은 java에서는 InputStream은 데이터를 byte로 읽고, Reader는 char로 읽는다는 점이다.
그럼 당연하게 byte로 읽는 것은 받아들일 수 있다.(우리가 이해하기엔 어려울지 몰라도)

아무튼 그렇다면 왜 int일까? 찾아보니 FileInputStream은 파일의 데이터를 int로 읽어서 4바이트 중 마지막 한 바이트(8bit) 부분에 읽어들인 바이트를 저장한다고 한다.
즉 한 바이트씩 읽어서 저장을 하는데 보관소로 int의 마지막 바이트에 저장한다는 것이다. (int는 4바이트이다. Integer.MIN_VALUE = 10000000.00000000.00000000."00000000")
그래서 어떻게 된다고?

파일에 A라는 글자가 있으면 read()로 읽었을 때, A라는 글자를 표현하는 한바이트 00000000.00000000.00000000.01000001로 읽어오게 된다. 10진수로는 65에 해당한다.

어 어디서 본 숫자인데? 그렇다 아스키코드에서 A에 매칭되는 10진수가 바로 65(01000001)이다. 이와 같이 해당 문자에 대해 한 바이트로 표현하고 있는 아스키코드를 이용해서 표현하고 있다.

그렇다면 우리는 이제 FileInputStream.read()에 대해서 알게 되었다. 파일로부터 데이터(한 글자)를 읽게 되는데 int로 읽는다. 만약 그 값이 65라면 A라는 글자, 95라면 a라는 글자라는 것을 알 수 있다.
그리고 마지막 바이트에만 쓰기 때문에, 한바이트(8bit)를 넘는 숫자가 나올 수 없다는 것도 유추해볼 수 있다. (0~255)

그러면 이제 쓰기를 해보자 FileOutputStream에서도 write(int)메소드가 있고, write(byte[])가 있다.
여기서 우린 write(int)를 생각해보자. 앞에서와 마찬가지고 우리가 A라는 글자를 쓰고 싶으면, write(65)해주면 된다. 쉽다

여기서도 어차피 마지막 바이트(8비트)만 신경 쓰므로 0~255만 유효하다. 그 이후의 숫자는 넘길 수 있지만 그 숫자의 마지막 바이트만 생각하여 write된다.
아까 Integer.MIN_VALUE의 경우 마지막 바이트가 00000000 이므로 0과 동일한 데이터가 write() 된다.

그럼 bytes[]로 쓰는 일은 언제일까?
하나씩 읽어오거나 쓰는 방법은 비효율적이다. 왜냐하면 os 자체적으로 512bytes를 읽어오기 때문이다. read()를 호출하면 내부적으로는 512바이트 단위로 읽어오고 그 중 1바이트만 쓰고 나머지 511바이트는 버린다. 이 일이 반복되는 것이다.
그러므로 읽어올 때 bytes[512]단위로 읽어오는 것이 좋다. 어차피 512바이트를 읽어오기 때문에 512로 읽어오는 것이 속도도 더 빠르다.

write(bytes[], 0, readCount)는 bytes[]배열의 0번부터 readCount까지를 해당 파일에 추가로 쓴다는 의미이다.(append)


